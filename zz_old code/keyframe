//.h
  //! Method to compare the current Keyframe to a 2D Frame
  //! \param[in] frame Frame to compare
  //! \param[out] idx_matching_points Vector of pairs of indexes: (i,j) with i the map index, j the frame index
  //! \param[out] keyframe_matching_points Vector of matching points (3D) in the Keyframe
  //! \param[out] frame_matching_points Vector of matching points (2D) in the Frame
  void matchWithFrame(Frame& frame, std::vector< std::vector< int > >& idx_matching_points,
                      std::vector< cv::Point3f >& keyframe_matching_points,
                      std::vector< cv::Point2f >& frame_matching_points);







//.cpp
void Keyframe::matchWithFrame(Frame& frame, std::vector< std::vector< int > >& idx_matching_points,
                              std::vector< cv::Point3f >& keyframe_matching_points,
                              std::vector< cv::Point2f >& frame_matching_points)
{
  if (frame.descriptors.rows == 0 || this->descriptors.rows == 0)
    return;
  std::vector<cv::DMatch> simple_matches;
  map->matcher.match(frame.descriptors, this->descriptors, simple_matches);

  // threshold test
  for (unsigned k = 0; k < simple_matches.size(); k++)
  {
    if (simple_matches[k].distance < DIST_THRESHOLD)
    {
      std::vector<int> v(2);
      v[0] = simple_matches[k].trainIdx;
      v[1] = simple_matches[k].queryIdx;
      idx_matching_points.push_back(v);

      cv::Point3f keyframe_point;
      //TODO attention avant c'Ã©tait this->cloud (quand cette fonction etait encore utilisee et keypoint avait un cloud)
      pcl::PointXYZRGBSIFT pcl_point = this->map->cloud->points[simple_matches[k].trainIdx];
      keyframe_point.x = pcl_point.x;
      keyframe_point.y = pcl_point.y;
      keyframe_point.z = pcl_point.z;
      keyframe_matching_points.push_back(keyframe_point);
      frame_matching_points.push_back(frame.img_points[simple_matches[k].queryIdx]);
    }
  }
}





  //! Constructor
  //! \param[in] map Pointer to the map
  //! \param[in] pose Pose of the drone from which the keypoints were observed
  //! \param[in] frame from which the Keyframe is built
  Keyframe(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud,
     cv::Mat* descriptors, const boris_drone::Pose3D& pose, const Frame& frame);


Keyframe::Keyframe(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud,
   cv::Mat* map_descriptors, const boris_drone::Pose3D& pose, const Frame& frame)
{
  tf::Matrix3x3 drone2world, cam2drone, cam2world;
  double roll, pitch, yaw;
  drone2world.setRPY(pose.rotX, pose.rotY, pose.rotZ);
  cam2drone.setRPY(-PI/2, 0, -PI/2);
  cam2world = drone2world*cam2drone;
  cam2world.getRPY(roll, pitch, yaw);
  this->pose            = pose; //old: just this
  this->pose.rotX       = roll;
  this->pose.rotY       = pitch;
  this->pose.rotZ       = yaw;
  this->cloud           = cloud;
  this->map_descriptors = map_descriptors;
  this->img_points       = frame.img_points;
  this->descriptors     = frame.descriptors;
  this->npts            = frame.img_points.size();
  //set all point_is_mapped to false
  this->point_is_mapped.resize(npts,false);
  this->points.resize(npts,-1);

  //Old, to remove when not used anymore:
  this->unmapped_img_points  = frame.img_points;
}

/*
OLD:
Keyframe::Keyframe(const Frame& frame, Camera* cam, const boris_drone::Pose3D pose)
{
  this->camera = cam;
  this->ID = ID_counter++;
  tf::Matrix3x3 drone2world, cam2drone, cam2world;
  double roll, pitch, yaw;
  drone2world.setRPY(pose.rotX, pose.rotY, pose.rotZ);
  cam2drone.setRPY(-PI/2, 0, -PI/2);
  cam2world = drone2world*cam2drone;
  cam2world.getRPY(roll, pitch, yaw);
  this->pose            = pose; //Rotation is to camera, not to drone
  this->pose.rotX       = roll;
  this->pose.rotY       = pitch;
  this->pose.rotZ       = yaw;
  this->img_points      = frame.img_points;
  this->descriptors     = frame.descriptors;
  this->npts            = frame.img_points.size();
  this->n_mapped_pts    = 0;
  this->point_IDs.resize(npts,-1);
  ROS_INFO("Created keyframe %d. It has %d (unmatched) points",ID,npts);
} */
